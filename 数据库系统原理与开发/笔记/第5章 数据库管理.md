## 5.1 数据库管理概述
1. #数据库管理 （Database Management）是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。
2. 数据库管理的必要性
	- 数据库系统随规模增大，系统会变得异常复杂
	- 多用户数据库应用带来数据库访问复杂性
	- 数据安全和数据隐私对机构和用户都非常重要
	- 数据库系统随数据量增加和使用时间增长其性能会降低
	- 系统遭遇意外事件，会发生数据库损坏或数据丢失
3. 数据库管理的目标
	- 保障数据库系统正常稳定运行
	- 充分发挥数据库系统的软硬件处理能力
	- 确保数据库系统安全和用户数据隐私性
	- 有效管理数据库用户及其角色权限
	- 解决数据库系统性能优化、系统故障与数据损坏等问题
	- 最大程度地发挥数据库对其所属机构的作用
4. 数据库管理的内容
	- DBMS系统运行管理
	- 数据库性能监控
	- 数据库索引管理
	- 数据库查询优化
	- 数据库事务并发控制
	- 数据库角色管理
	- 数据库用户管理
	- 数据库对象权限管理
	- 数据安全管理
	- 数据库备份与恢复等
5. 数据库管理员（DBA）的职责
	- 负责数据库系统开发与运维
	- 负责数据库用户与权限管理
	- 负责数据库备份与数据库恢复管理
	- 负责数据库性能调优管理等
6. DBMS管理功能
	1. 数据库定义
		- 数据库结构创建
		- 数据库结构修改
		- 完整性约束定义
		- 索引结构定义
	2. 数据库运行管理
		- 系统启停控制
		- 并发控制
		- 事务管理
		- 完全性控制
		- 完整性控制
		- 日志管理
		- 性能监控
	3. 数据库组织与存储
		- 缓冲区管理
		- 数据组织
		- 数据存取
	4. 数据库维护
		- 数据载入
		- 数据转换
		- 数据库备份
		- 数据库恢复
		- 数据库重构
		- 性能优化
	5. 数据库通信
		- 数据同步
		- 数据复制
		- 数据传输
7. DBMS系统层次结构
	1. 数据存储管理层：负责缓冲区管理、存储管理、索引管理等。
	2. 数据存取控制层：负责并发控制、事务管理、存取控制、权限控制、执行引擎、日志与恢复、性能监控等。
	3. 语言翻译处理层：负责编译与解释、视图转换、授权检查、完整性检查等。
	4. 数据存储管理层对接操作系统，语言翻译处理层对接应用接口。
8. 数据库DBMS服务器系统，一般都有相应的数据库管理工具，以便用户使用它们对数据库服务器及其数据库进行管理控制。
## 5.2 事务管理
### 一、事务
在数据库应用系统中，完成一个业务处理通常需要多个操作步骤才能完成处理。在每个操作步骤中，都可能遭遇失败，若没有一个处理机制，就可能造成操作数据混乱，从而破坏数据一致性。
1. #事务 （Transaction）是指构成单个业务处理单元的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。
2. 在数据库系统中，事务是DBMS执行的 #最小任务单元 。同时，事务也是DBMS最小的故障恢复任务单元和并发控制任务单元。其生命周期状态变迁为：
	- $开始<调度执行>\to [事务初始状态]<SQL操作成功>\to [事务正常状态]<Commit操作>\to [事务提交状态]<退出>\to 结束$
	- $开始<调度执行>\to [事务初始状态]<SQL操作失败>\to [事务失败状态]<Rollback回滚>\to [事务回滚状态]<退出>\to 结束$
3. 为了确保数据库共享访问的数据正确性，要求DBMS的事务管理机制维护事务的ACID特性。事务 #ACID 特性：
	- #原子性 （Atomicity）：事务所有操作在数据库中要么全部执行，要么全部不执行。
	- #一致性 （Consistency）：事务多次执行，其结果应一致。
	- #隔离性 （Isolation）：事务与事务之间隔离，并发执行透明。
	- #持续性 （Durability）：事务完成后，数据改变必须是永久的。
4. #事务并发执行 是指多个事务程序在数据库系统中同一时段运行。事务并发执行原因：
	- 改善系统的资源利用率
	- 减少事务运行的平均等待时间
### 二、事务SQL程序
在关系数据库系统中，可以利用SQL语言提供的相应语句编写事务程序。
1. 事务SQL语句
	- 事务开始语句：`BEGIN;` 或 `START TRANSACTION;`
	- 事务回滚语句：`ROLLBACK;`
	- 事务提交语句：`COMMIT;`
	- 事务保存语句：`SAVEPOINT;`
2. 事务SQL程序基本框架
	- `START TRANSACTION;SQL1;SQL2;...SQLn;COMMIT;`
	- `START TRANSACTION;SQL1;SQL2;...SQLn;ROLLBACK;`
	- `START TRANSACTION;SQL1;SQL2;...SAVEPOINT 保存点名;...SQLn;ROLLBACK 保存点名;`
3. 事务程序中不能使用的SQL语句
	- 创建数据库 `create database`
	- 修改数据库 `alter database`
	- 删除数据库 `drop database`
	- 恢复数据库 `restore database`
	- 加载数据库 `load database`
	- 备份日志文件 `backup log`
	- 恢复日志文件 `restore log`
	- 授权操作 `grant`
4. 若用户没有显式地定义事务，DBMS按默认事务方式处理，即每执行一个SQL语句将自动构成一个事务。若将多条SQL语句定义为一个事务时，才使用专门的事务SQL语句显式地定义事务。
## 5.3 并发控制
### 一、为什么需要并发控制
当多个事务程序在DBMS系统中同时运行时，可能会出现对一些共享数据同时进行访问操作，如一些事务修改数据，另一些事务读取数据。这些并发的共享数据操作，如果在DBMS中没有一定的约束控制，可能会带来数据不一致性或事务程序死锁问题。因此，在多个事务并发运行时，必须进行并发控制处理。
并发控制的目的：
- 支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力。
- 保证一个事务工作不会对另一个事务工作产生不合理的影响。
### 二、并发控制需解决的问题
1. #丢失更新数据
	- T1、T2两个事务并发执行，它们均对数据库共享数据A进行了非锁定资源的读写操作。
	- 当事务T1和T2均读入该共享数据A并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。
2. #不可重复读取 ：指一个事务对一个共享数据重复多次读取，但前后读取的数据不一致。
	- 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值。
	- 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了。也称为不可重复读取。
	- 事务T1按一定条件从数据库中读取某些数据记录后，事务T2在其中插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。称为 #幻象读取 。
3. #脏数据读取 ：值一个事务读取了被取消持久化的共享数据。
	- 事务T2并不知道C值被T1恢复，因此，事务T2读取了脏数据。
### 三、并发事务调度原理与策略
事务并发执行可能带来的问题：当多个事务并发存取共享数据时，由于不当的数据操作顺序，可能出现数据不一致性问题（如丢失更新数据、不可重复读、脏数据读等问题）。
#并发事务调度 就是控制多个事务的数据操作语句按照恰当的顺序访问共享数据，使这些事务执行之后，避免造成数据的不一致性，即解决丢失更新数据、不可重复读、脏数据读等问题。
1. 事务调度原理：在DBMS中，事务管理器将并发执行事务的SQL数据操作请求提交给并发控制调度器。由并发控制调度器将各个事务的SQL数据操作请求按照一定顺序进行调度执行，并完成对数据库缓冲区的读写操作。
2. 事务调度策略：在事务并发执行中，只有当事务中数据操作调度顺序的执行结果与事务串行执行结果一样时，该并发事务调度才能保证数据操作的正确性和一致性。符合这样效果的调度称为 #可串行化调度 。
3. DBMS并发事务调度目标：使并发事务调度实现的处理结果与串行化调度处理结果一致。
### 四、数据库锁机制
为了解决多个事务并发对共享数据进行新增、更新、删除、查询带来的数据不一致问题时，需要对共享数据进行加锁访问。
1. #资源锁定访问 在DBMS中，通过加入锁表机制，来实现共享数据锁定访问，其加锁方式包含如下类型：
	- 排它锁定（Lock-X）：锁定后，不允许其它事务对共享数据再加锁
	- 共享锁定（Lock-S）：锁定后，只允许其它事务对共享数据添加读取锁
2. 资源锁定粒度：数据库>表>页面>行
3. 资源锁定实施方式：
	- 隐式锁定：DBMS缺省执行
	- 显式锁定：加锁命令显式执行
### 五、基于锁机制的并发控制协议
为了实现并发事务对共享数据访问的串行化调度执行，还必须约束它们对共享数据的操作访问必须是以互斥方式进行。这就需要用到基于数据库锁机制的并发控制协议。
1. 锁操作的相容性

|         | 排它锁 | 共享锁 | 无锁  |
| ------- | --- | --- | --- |
| **排它锁** | 否   | 否   | 是   |
| **共享锁** | 否   | 是   | 是   |
| **无锁**  | 是   | 是   | 是   |
2. 加锁协议：
	1. 一级加锁协议：任何事物在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。
		- 使用一级加锁协议，可避免出现更新丢失问题。但不能解决不可重复读、脏读等数据不一致问题。
	2. 二级加锁协议：在一级加锁协议基础上，针对并发事务的共享数据读操作，必须对该数据执行共享锁定指令，读完数据后即刻释放共享锁定。
		- 该加锁协议不但可以防止丢失更新的数据不一致性问题，还可防止出现脏读数据问题。但有可能会出现不可重复读取的数据不一致问题。
	3. 三级加锁协议：在一级加锁协议基础上，针对并发事务的共享数据进行读操作，必须对该数据执行共享锁定指令，直到该事务处理结束才释放共享锁定。
		- 该加锁协议不但可以防止丢失更新、脏读的数据不一致性问题，还可防止出现不可重复读取的数据一致性问题。
3. 不同级别锁协议比较

| 加锁协议级别 | 排它锁  | 共享锁            | 不丢失更新 | 不脏读 | 可重复读 |
| ------ | ---- | -------------- | ----- | --- | ---- |
| 一级     | 全程加锁 | 不加             | 是     | 否   | 否    |
| 二级     | 全程加锁 | 开始时加锁，读完数据释放锁定 | 是     | 是   | 是    |
| 三级     | 全程加锁 | 全程加锁           | 是     | 是   | 是    |
### 六、两阶段锁定协议
1. 并发事务的正确调度准则：一个给定的并发事务调度，当且仅当它是可串行化时，才能保证正确调度。保证可串行化的一个协议是： #二阶段锁定协议 。
2. 二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请：
	- 增长阶段，事务只能获得锁，但不能释放锁。
	- 缩减阶段，事务只能释放锁，但不能获得新锁。
	- 若并发事务执行的所有事务都遵从两阶段锁定协议，则这些事务的任何并发调度都是可串行化调度，即这些并发调度执行结果可以保证数据库一致性。
### 七、死锁问题解决
1. #事务死锁 在基于锁机制的并发事务执行中，如果这些事务同时锁定两个及以上资源时 ，可能会出现彼此都不能继续执行的状态，即事务死锁状态。
2. #死锁 出现的必要条件
	- 互斥条件
	- 请求和保持条件
	- 不剥夺条件
	- 环路等待条件
3. 防范死锁的策略
	- 允许用户一次发出当前所需全部资源的锁定，使用完成后，再释放给其它用户访问
	- 规定所有应用程序锁定资源的顺序必须完全相同
4. 解决死锁的办法：当发生死锁时，回滚其中的一个事务，并取消它对数据库所做的改动。
### 八、事务隔离级别

| 隔离级别  | 脏读  | 不可重复读 | 幻象读 | 丢失更新 |
| ----- | --- | ----- | --- | ---- |
| 读取未提交 | 可能  | 可能    | 可能  | 可能   |
| 读取已提交 | 不可能 | 可能    | 可能  | 可能   |
| 可重复读  | 不可能 | 不可能   | 可能  | 可能   |
| 可串行化  | 不可能 | 不可能   | 不可能 | 不可能  |
说明：事务隔离级别设置是在DBMS中执行`set transaction`命令来实现或通过管理工具设置的。事务隔离级别越高，出现数据不一致的可能性越小，但系统吞吐量也越小。
## 5.4 安全管理
### 一、数据库系统面临的安全风险
- 黑客利用系统漏洞，攻击系统运行、窃取和篡改系统数据。
- 内部人员非法地泄露、篡改、删除系统的用户数据。
- 系统运维人员操作失误导致数据被删除或数据库服务器系统宕机。
- 系统故障导致数据库的数据损坏、数据丢失、数据库实例无法启动。
- 意外灾害事件（火灾、水灾、地震等自然灾害）导致系统被破坏等。
### 二、数据库系统安全模型
1. 身份验证：从应用系统层面确认登录用户是否是合法使用者
2. 权限控制：从DBMS系统层面通过存取权限机制控制用户对数据的访问
3. 系统防护：从操作系统层面提供的安全机制防范非法系统访问
4. 加密存储：从数据存储层面通过加密算法对数据库中数据进行加密存储
### 三、数据库存取权限控制安全模型
![[1_数据库存取权限控制安全模型.png]]
### 四、用户管理
用户要访问数据库，必须先在DBMS中创建其账号，并成为数据库的用户。此后，用户每次访问数据库，都需要在DBMS进行身份验证，只有合法用户才能进入系统，访问操作数据库对象。
#用户管理 在数据库安全管理中，DBMS需要对每个用户进行管理，如用户创建、用户修改、用户删除管理等。实现用户管理的方式：
- 数据库服务器执行SQL语句管理用户
- 通过管理工具GUI操作管理用户
1. 用户创建语句  `create user <用户账号名> [[with] option [...]];`
2. 用户修改语句
	- 修改用户的属性 `alter user <用户名> [[with] option [...]];`
	- 修改用户的名称 `alter user <用户名> rename to <新用户名>;`
	- 修改用户的参数值 `alter user <用户名> set <参数值> {to |= } {value | default};`
	- 重置用户参数值 `alter user <用户名> reset <参数项>;`
3. 用户删除语句 `drop user <用户名>;`
### 五、权限管理
#数据库权限管理 是指DBA管理员或数据库对象拥有者对其所拥有对象进行权限控制设置。权限管理基本操作：
- 授予权限 `grant <权限名> on <对象名> to {数据库用户名|用户角色名};`
- 收回权限 `revoke <权限名> on <对象名> from {数据库用户名|用户角色名};`
- 拒绝权限 `deny <权限名> on <对象名> to {数据库用户名|用户角色名};`
权限类别：
- 数据库系统权限
- 数据库对象访问操作权限
- 数据库对象定义操作权限
### 六、角色管理
在DBMS中，为了方便对众多用户及其权限进行管理，通常将一组具有相同权限的用户定义为 #角色 （ #Role ）。角色管理内容：
- 创建角色 `create role <角色名> [[with] option [...]];`
- 修改角色
	- 修改角色属性 `alter role <角色名> [[with] option [...]];`
	- 修改角色名称 `alter role <角色名> rename to <新角色名>;`
	- 修改角色参数值 `alter role <角色名> set <参数项> { to|=}{ value|default};`
	- 复位角色参数值 `alter role <角色名> reset <参数项>;`
- 删除角色 `drop role <角色名>;`
角色管理实现方式：
- 执行SQL语句管理角色
- 通过GUI操作管理角色
## 5.5 数据库备份与恢复
### 一、数据库系统故障原因
- 数据库服务器硬件故障
- 系统软件故障
- 用户误操作
- 系统意外断电
### 二、数据库备份与恢复
#数据库备份 是指将数据库当前数据和状态进行副本复制，以便当数据库收到破坏或丢失数据时可以进行修复。
#数据库恢复 是指数据库中数据丢失或被破坏时，从备份副本将数据库从错误状态恢复到某一正确状态。
### 三、备份内容与备份角色
#备份内容 包括数据文件、日志文件等。
#备份角色 可以是服务器管理员（sysadmin）、数据库所有者（db_owner）、数据库备份员（db_backupoperator）角色之一。
### 四、备份介质与备份时机
#备份介质 包括磁盘阵列、磁带库、光盘库等。
#备份时机 当系统数据库重要数据被修改、日志被清理、用户数据库加载等事件出现时。
### 五、数据库备份方法
- 完全备份
- 差异备份
- 事务日志备份
- 文件备份
- 冷备份
- 热备份
### 六、数据库备份实现
备份实现方式：
- 执行实用程序命令实现备份（`pg_dump`或`pg_dumpall`）
- 操作GUI工具实现备份
### 七、数据库恢复方法
1. 通过备份文件进行恢复（`psql`或`pg_restore`）：使用备份数据库文件将数据库恢复到一个已知节点后，再重新处理当时的所有工作。
	- 恢复技术简单，易于实现
	- 对于多用户系统，难以接受备份周期内出现的数据丢失
2. 利用事务日志按前滚或回滚方式进行数据库恢复
### 八、基于GUI的PostgreSQL数据库系统备份与恢复
