1. 定义：
	- #前缀 设$\beta=a_1a_2a_3...a_n$为长度为n的符号串，称$a_1,a_1a_2,...,a_1a_2a_3...a_{n-1}$分别为符号串$\beta$的长度为$1,2,...,n-1$的前缀；
	- #前缀码 设$B=\{{\beta}_1,{\beta}_2,...,{\beta}_m\}$为一个字符串集合，若对任意的${\beta}_i,{\beta}_j\in B,i\ne j，{\beta}_i,{\beta}_j$互不为前缀，则称B为前缀码；
	- #二元前缀码 若${\beta}_i(i=1,2,...,m)$中只有0，1两个符号，则称B为二元前缀码。
		- 例如，{0,10,110,111}，{11,00,010,011}都是二元前缀码，{1,01,010,110}不是前缀码。
	- 用前缀码编码不会产生歧义。
2. 定理：任何一棵二元树的树叶可对应一个前缀码。
3. 定理：任何一个前缀码都对应一棵二元树。
4. 定义：给定一组权：$w_1,w_2,...,w_n$，如果2元树T有n片树叶$v_1,v_2,...,v_n$，树叶的权分别为$w_1,w_2,...,w_n$，称2元树T为带权$w_1,w_2,...,w_n$的二元树。称$W(T)=\sum_{i=1}^{n}w_il(v_i)$为T的 #权 ，其中$l(v_i)$是树叶$v_i$的层数。在所有带权$w_1,w_2,...,w_n$的2元树中，称权最小的2元树的 #最优2元树 #最优二元树 。
5. 求最优2元树的算法（哈夫曼(Huffman)算法）
	1. 画t个结点作为树叶，对应给定的t个权值。
	2. 在所有入度为0的结点中选出权值最小的两个结点（树叶或分支点），以这两个结点为子结点，添加一个新分支点，分支点的权值是这两个结点的权值和。
	3. 重复(2)，直到得到只有一个入度为0的结点的二元树。这棵二元树就是最优二元树，又称 #哈夫曼树 。
6. 最佳前缀码
	- 最优二元树是带权路径长度最小的二元树。
	- 通过最优二元树（哈夫曼树）构造的编码称为 #哈夫曼编码 。
	- 哈夫曼编码可用于数据压缩。
	- 最佳前缀码：当要传输按一定比例出现的符号组成的符号串时，用最少的二进制数字传输它们的前缀码，称为 #最佳前缀码 。
	- 哈夫曼编码是最佳前缀码。
7. 在根树中，每个分支点都对应一个决策，分支点的子树对应该决策的每种可能结果，称这样的根树为 #决策树 。