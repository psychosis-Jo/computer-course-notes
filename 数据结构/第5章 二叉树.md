## 5.0 前言
数据结构
- 线性结构（linear structure）
	- 基于数组实现
		- 允许通过下标或秩，在常数时间内找到目标对象；但对这类结构进行修改，无论是插入还是删除，都需要耗费线性的时间。
		- 如数组、向量
	- 基于链表实现
		- 允许借助引用或位置对象，在常数时间内插入或删除元素；但查找特定次序的元素时，需花费线性的时间，对整个结构进行遍历查找。
		- 如链表
	- 栈与队列，即可基于数组实现，也可基于链表实现
- 半线性结构（semi-linear structure）
	- 如树
树的元素之间并不存在天然的直接后继或直接前驱关系，但只要附加某种约束（比如遍历），也可以在树中的元素之间确定某种线性次序，因此树属于 #半线性结构 （semi-linear structure）。
平衡二叉搜索树，若其中包含n个元素，则每次查找、更新、插入或删除操作都可在$O(\log n)$时间内完成——相对于线性结构，几乎提高了一个线性因子。
树结构有着不计其数的变种，在算法理论以及实际应用中，它们都扮演着最为关键的角色。之所以如此，是因得益于其独特而又普适的逻辑结构。树是一种分层结构，而层次化这一特征几乎蕴含于所有事物及其联系当中，成为其本质属性之一。从文件系统、互联网域名系统和数据库系统，一直到地球生态系统乃至人类社会系统，层次化特征以及层次结构均无所不在。
作为树的特例，二叉树实际上并不失其一般性。无论就逻辑结构或算法功能而言，任何有根有序的多叉树，都可等价地转化并实现为二叉树。
## 5.1 二叉树及其表示
### 5.1.1 树
1. 有根树
	从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组 #顶点 （ #vertex ）以及连接与其间的若干条 #边 （ #edge ）组成。在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为 #根 （ #root ）。在指定根节点之后，也称之为 #有根树 （rooted tree）。从程序实现的角度，顶点也称作 #节点 （ #node ）。
2. 深度与层次
	由树的连通性，每一节点与根之间都有一条路径相连：而根据树的无环性，由根通往每个节点的路径必然唯一。因此如图5.1所示，沿每个节点v到根r的唯一通路所经过边的数目，称作v的深度（depth），记作`depth(v)`。依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度$depth(r)=0$，故属于第0层。
	![[43_有根树的逻辑结构.png]]
3. 祖先、后代与子树
	任一节点v在通往树根沿途所经过的每个节点都是其 #祖先 （ #ancestor ），v是它们的 #后代 （ #descendant ）。特别地，v的祖先/后代包括其本身，而v本身以外的祖先/后代称作 #真祖先 （proper ancestor）/ #真后代 （proper descendant）。
	节点v历代祖先的层次，自下而上以1为单位逐层递减；在每一层次上，v的祖先至多一个。特别地，若节点u是v的祖先且恰好比v高出一层，则称u是v的 #父亲 （ #parent ），v是u的 #孩子 （ #child ）。
	v的孩子总数，称作其 #度数 或 #度 （ #degree ），记作$deg(v)$。无孩子的节点称作 #叶节点 （ #leaf ），包括根在内的其余节点皆为 #内部节点 （internal node）。
	v所有的后代及其之间的连边称作 #子树 （ #subtree ），记作$subtree(v)$。在不致歧义时，往往不再严格区分节点（v）及以之为根的子树（subtree(v)）。
4. 高度
	树T中所有节点深度的最大值称作该树的 #高度 （ #height ），记作 $height(T)$。
	树的高度总是由其中某一叶节点的深度确定，特别地，仅含单个节点的树高度为0，空树高度为-1。
	任一节点v所对应子树$subtree(v)$的高度，亦称作该节点的高度，记作$height(v)$。特别地，全树的高度即其根节点r的高度，$height(T)=height(r)$。
### 5.1.2 二叉树
![[44_二叉树逻辑结构及实例.png]]
如图5.2所示， #二叉树 （binary tree）中每个节点的度数均不超过2。
因此在二叉树中，同一父节点的孩子都可以左、右相互区分——此时，亦称作 #有序二叉树 （ordered binary tree）。此处所提二叉树，默认有序。
特别地，不含一度节点的二叉树称作 #真二叉树 （proper binary tree）。
### 5.1.3 多叉树
一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过k个的有根树，称作 #k叉树 （k-ary tree）。
1. 父节点
	![[45_多叉树的父节点表示法.png]]
	如图5.3(a)，在多叉树中，根节点以外的任一节点有且仅有一个父节点。
	因此可如图5.3(b)，将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点-1或NULL，以便统一判断。
	如此，所有向量或列表所占的空间总量为$O(n)$，线性正比于节点总数n。时间方面，仅需常数时间，即可确定任一节点的父节点；但反过来，孩子节点的查找却不得不花费$O(n)$时间访遍所有节点。
2. 孩子节点
	![[46_多叉树的孩子节点表示法.png]]
	若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有r个孩子的节点，可在$O(r+1)$时间内列举出其所有的孩子。
3. 父节点+孩子节点
	![[47_多叉树的父+孩子节点表示法.png]]
	以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为总和二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。
	尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入和删除操作频繁的场合，为动态地维护和更新树的拓补结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需消耗大量时间，势必影响到整体的效率。
4. 有序多叉树=二叉树
	解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。
	仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。幸运的是，这一附加条件在实际应用问题中往往自然满足。以互联网域名系统所对应的多叉树为例，其中同一域名下的分支通常即按照字典序排列。
5. 长子+兄弟
